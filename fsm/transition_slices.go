// Generated by slice (github.com/schigh/slice). DO NOT EDIT.

package fsm

// TransitionSlice aliases []Transition
type TransitionSlice []Transition

// Value returns the wrapped Transition slice
func (slc TransitionSlice) Value() []Transition {
	return []Transition(slc)
}

// Map applies a function to every Transition in the slice.  This function will mutate the slice in place
func (slc TransitionSlice) Map(f func(Transition) Transition) {
	for i := 0; i < len(slc); i++ {
		slc[i] = f(slc[i])
	}
}

// Filter evaluates every element in the slice, and returns all Transition
// instances where the eval function returns true
func (slc TransitionSlice) Filter(f func(Transition) bool) TransitionSlice {
	out := make([]Transition, 0, len(slc))
	for i := 0; i < len(slc); i++ {
		if f(slc[i]) {
			out = append(out, slc[i])
		}
	}

	return TransitionSlice(out)
}

// Each applies a function to every Transition in the slice.
func (slc TransitionSlice) Each(f func(Transition)) {
	for i := 0; i < len(slc); i++ {
		f(slc[i])
	}
}

// TryEach applies a function to every Transition in the slice,
// and returns the index of the element that caused the first error, and the error itself.
// If every member of the slice returns nil, this function will return (-1, nil)
// The iteration will halt on the first error encountered and return it.
func (slc TransitionSlice) TryEach(f func(Transition) error) (int, error) {
	for i := 0; i < len(slc); i++ {
		if err := f(slc[i]); err != nil {
			return i, err
		}
	}

	return -1, nil
}

// IfEach applies a function to every Transition in the slice,
// and returns the index of the element that caused the function to return false.
// If every member of the slice evaluates to true, this function will return (-1, true)
// The iteration will halt on the first false return from the function.
func (slc TransitionSlice) IfEach(f func(Transition) bool) (int, bool) {
	for i := 0; i < len(slc); i++ {
		if !f(slc[i]) {
			return i, false
		}
	}

	return -1, false
}

// Chunk divides the slice into equally sized chunks
func (slc TransitionSlice) Chunk(size int) [][]Transition {
	l := len(slc)
	if l == 0 || size <= 0 {
		return make([][]Transition, 0)
	}

	floor := l / size
	out := make([][]Transition, 0, floor+1)
	var k int

	for i := 0; i < floor; i++ {
		k = i*size + size
		out = append(out, slc[i*size:k])
	}
	if l > k {
		out = append(out, slc[k:])
	}

	return out
}
